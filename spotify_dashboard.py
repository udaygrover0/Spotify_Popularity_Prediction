# -*- coding: utf-8 -*-
"""Spotify_Dashboard.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1FlOzl2wPDC65IAtPjFbj0ePQ5dP-x7Iw
"""

import streamlit as st
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import joblib

st.title("Song Popularity Prediction")
st.markdown("A model to predict the popularity of a song based on its features. \
            Adjust the sliders to see how different features influence the predicted popularity of the song.")

st.header("Song Features")

# User input fields
danceability = st.slider("Danceability", 0.0, 1.0, 0.5)
energy = st.slider("Energy", 0.0, 1.0, 0.5)
key = st.selectbox("Key", range(12))
loudness = st.slider("Loudness", -60.0, 0.0, -30.0)
speechiness = st.slider("Speechiness", 0.0, 1.0, 0.5)
acousticness = st.slider("Acousticness", 0.0, 1.0, 0.5)
instrumentalness = st.slider("Instrumentalness", 0.0, 1.0, 0.5)
liveness = st.slider("Liveness", 0.0, 1.0, 0.5)
valence = st.slider("Valence", 0.0, 1.0, 0.5)
tempo = st.slider("Tempo", 0.0, 250.0, 120.0)

# New fields based on previously dropped data
track_artist = st.text_input("Artist Name", "Unknown Artist")
track_album_name = st.text_input("Album Name", "Unknown Album")
track_album_release_date = st.date_input("Release Date")

# Load model
def predict(data):
    model = joblib.load("popularity_model.pkl")  # Assuming the model file is named 'popularity_model.pkl'
    return model.predict(data)

# Convert user inputs into a DataFrame for visualization
input_data = pd.DataFrame({
    'Danceability': [danceability],
    'Energy': [energy],
    'Key': [key],
    'Loudness': [loudness],
    'Speechiness': [speechiness],
    'Acousticness': [acousticness],
    'Instrumentalness': [instrumentalness],
    'Liveness': [liveness],
    'Valence': [valence],
    'Tempo': [tempo]
})

# Visualizations
st.subheader("Feature Distributions")
st.markdown("These charts reflect the impact of different song features on popularity.")

# Danceability vs. Popularity
fig, ax = plt.subplots()
sns.scatterplot(data=input_data, x="Danceability", y="Tempo", ax=ax)
ax.set_title("Danceability vs Tempo")
st.pyplot(fig)

# Loudness vs. Popularity
fig, ax = plt.subplots()
sns.scatterplot(data=input_data, x="Loudness", y="Energy", ax=ax)
ax.set_title("Loudness vs Energy")
st.pyplot(fig)

# Feature Importance Visualization
st.subheader("Feature Importance")
st.markdown("The following bar chart shows the importance of each feature in determining the popularity.")

# Assuming you have a model with feature importance (e.g., RandomForest)
model = joblib.load("popularity_model.pkl")
feature_importance = model.feature_importances_

# Plotting feature importance
fig, ax = plt.subplots()
importance_df = pd.DataFrame({
    'Feature': ['Danceability', 'Energy', 'Key', 'Loudness', 'Speechiness', 'Acousticness',
                'Instrumentalness', 'Liveness', 'Valence', 'Tempo'],
    'Importance': feature_importance
}).sort_values(by='Importance', ascending=False)

sns.barplot(x='Importance', y='Feature', data=importance_df, ax=ax)
ax.set_title("Feature Importance")
st.pyplot(fig)

# Correlation Heatmap
st.subheader("Correlation Heatmap")
st.markdown("The heatmap below shows the correlation between the different features and the target variable (popularity).")

# For the heatmap, you need to calculate correlations (you might need a larger dataset for this)
# For demonstration, assuming 'data' contains all features and the target 'popularity'
# Uncomment and modify the next line if you have a larger dataset or a preloaded one
# full_data = pd.read_csv('your_dataset.csv')  # Replace with your actual dataset

# Here we use the current input for demo purposes (not as accurate due to small sample)
full_data = pd.concat([input_data] * 100)  # Simulating a larger dataset
full_data['Popularity'] = predict(full_data[input_data.columns])  # Simulated prediction

correlation_matrix = full_data.corr()

fig, ax = plt.subplots()
sns.heatmap(correlation_matrix, annot=True, cmap='coolwarm', ax=ax)
ax.set_title("Correlation Heatmap")
st.pyplot(fig)

# Predict song popularity
if st.button("Predict Song Popularity"):
    result = predict(np.array([[danceability, energy, key, loudness, speechiness, acousticness,
                                instrumentalness, liveness, valence, tempo]]))
    st.subheader("Predicted Popularity Score")
    st.text(f"{result[0]:.2f} out of 100")

# Additional summary or interpretations
st.subheader("Summary")
st.markdown(f"The model predicts the popularity score based on the features provided for the song '{track_artist}' from the album '{track_album_name}', released on {track_album_release_date}. Adjust the sliders to see how the features impact the prediction.")